<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>avclj documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version">1.00-beta-1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="avclj.html"><div class="inner"><span>avclj</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="avclj.html#var-decoder-names"><div class="inner"><span>decoder-names</span></div></a></li><li class="depth-1"><a href="avclj.html#var-encoder-names"><div class="inner"><span>encoder-names</span></div></a></li><li class="depth-1"><a href="avclj.html#var-find-decoder"><div class="inner"><span>find-decoder</span></div></a></li><li class="depth-1"><a href="avclj.html#var-find-encoder"><div class="inner"><span>find-encoder</span></div></a></li><li class="depth-1"><a href="avclj.html#var-frame-buffer-shape"><div class="inner"><span>frame-buffer-shape</span></div></a></li><li class="depth-1"><a href="avclj.html#var-initialize.21"><div class="inner"><span>initialize!</span></div></a></li><li class="depth-1"><a href="avclj.html#var-list-codecs"><div class="inner"><span>list-codecs</span></div></a></li><li class="depth-1"><a href="avclj.html#var-list-pix-formats"><div class="inner"><span>list-pix-formats</span></div></a></li><li class="depth-1"><a href="avclj.html#var-make-video-decoder"><div class="inner"><span>make-video-decoder</span></div></a></li><li class="depth-1"><a href="avclj.html#var-make-video-encoder"><div class="inner"><span>make-video-encoder</span></div></a></li><li class="depth-1"><a href="avclj.html#var-PVideoDecoder"><div class="inner"><span>PVideoDecoder</span></div></a></li><li class="depth-2"><a href="avclj.html#var-decode-frame.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>decode-frame!</span></div></a></li><li class="depth-1"><a href="avclj.html#var-PVideoEncoder"><div class="inner"><span>PVideoEncoder</span></div></a></li><li class="depth-2"><a href="avclj.html#var-encode-frame.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>encode-frame!</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">avclj</h1><div class="doc"><div class="markdown"><p>libavcodec (FFMPEG) bindings for Clojure.</p>
<pre><code class="clojure">user&gt; (require '[avclj :as avclj])
nil
user&gt; (require '[avclj.av-codec-ids :as codec-ids])
nil
user&gt; (require '[tech.v3.tensor :as dtt])
nil
user&gt; (avclj/initialize!)
:ok
user&gt; (defn img-tensor
  [shape ^long offset]
  (dtt/compute-tensor shape
                      (fn [^long y ^long x ^long c]
                        (let [ymod (-&gt; (quot (+ y offset) 32)
                                       (mod 2))
                              xmod (-&gt; (quot (+ x offset) 32)
                                       (mod 2))]
                          (if (and (== 0 xmod)
                                   (== 0 ymod))
                            255
                            0)))
                      :uint8))
#'user/img-tensor
user&gt; (let [encoder-name codec-ids/AV_CODEC_ID_H264
            output-fname "test/data/test-video.mp4"]
        (with-open [encoder (avclj/make-video-encoder 256 256 output-fname
                                                      {:encoder-name encoder-name})]
          (dotimes [iter 125]
            (avclj/encode-frame! encoder (img-tensor [256 256 3] iter)))))
nil
</code></pre>
<ul>
  <li>To use this with buffered images, make sure the pixel formats match and be sure to require <code>tech.v3.libs.buffered-image</code>.</li>
  <li>If you have a system that is producing java.nio.ByteBuffers then require <code>tech.v3.datatype.nio-buffer</code>.</li>
</ul>
<p>For manipulating h264 encoder properties, use the <code>:codec-private-options</code> and  the various possibilities from the <a href="https://trac.ffmpeg.org/wiki/Encode/H.264">ffmpeg libx264 page</a>.</p></div></div><div class="public anchor" id="var-decoder-names"><h3>decoder-names</h3><div class="usage"><code>(decoder-names)</code></div><div class="doc"><div class="markdown"><p>List all decoder names</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/avclj/blob/master/src/avclj.clj#L113">view source</a></div></div><div class="public anchor" id="var-encoder-names"><h3>encoder-names</h3><div class="usage"><code>(encoder-names)</code></div><div class="doc"><div class="markdown"><p>List all of the encoder names</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/avclj/blob/master/src/avclj.clj#L104">view source</a></div></div><div class="public anchor" id="var-find-decoder"><h3>find-decoder</h3><div class="usage"><code>(find-decoder decoder-name)</code></div><div class="doc"><div class="markdown"><p>Find an encoder by name. Name may either be the ffmpeg encoder name such as “libx264” or it may be a codec id in <code>avclj.av-codec-ids</code> such as <code>avclj.av-codec-ids/AV_CODEC_ID_H264</code>.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/avclj/blob/master/src/avclj.clj#L138">view source</a></div></div><div class="public anchor" id="var-find-encoder"><h3>find-encoder</h3><div class="usage"><code>(find-encoder encoder-name)</code></div><div class="doc"><div class="markdown"><p>Find an encoder by name. Name may either be the ffmpeg encoder name such as “libx264” or it may be a codec id in <code>avclj.av-codec-ids</code> such as <code>avclj.av-codec-ids/AV_CODEC_ID_H264</code>.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/avclj/blob/master/src/avclj.clj#L128">view source</a></div></div><div class="public anchor" id="var-frame-buffer-shape"><h3>frame-buffer-shape</h3><div class="usage"><code>(frame-buffer-shape height width pixel-fmt)</code></div><div class="doc"><div class="markdown"><p>Return a vector of buffer shapes. Corresponds to the require input format of encode-frame!. Note that for planar pixel formats you will have to pass in multiple buffers.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/avclj/blob/master/src/avclj.clj#L174">view source</a></div></div><div class="public anchor" id="var-initialize.21"><h3>initialize!</h3><div class="usage"><code>(initialize!)</code></div><div class="doc"><div class="markdown"><p>Initialize the library. Dynamically must find libavcodec and libswscale. Attempts to load x264 to enable h264 encode.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/avclj/blob/master/src/avclj.clj#L90">view source</a></div></div><div class="public anchor" id="var-list-codecs"><h3>list-codecs</h3><div class="usage"><code>(list-codecs)</code></div><div class="doc"><div class="markdown"><p>List all available encoder/decoders</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/avclj/blob/master/src/avclj.clj#L122">view source</a></div></div><div class="public anchor" id="var-list-pix-formats"><h3>list-pix-formats</h3><div class="usage"><code>(list-pix-formats)</code></div><div class="doc"><div class="markdown"><p>List all available pixel format names.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/avclj/blob/master/src/avclj.clj#L148">view source</a></div></div><div class="public anchor" id="var-make-video-decoder"><h3>make-video-decoder</h3><div class="usage"><code>(make-video-decoder fname &amp; [{:keys [output-pixfmt output-height output-width], :or {output-pixfmt "AV_PIX_FMT_BGR24"}}])</code></div><div class="doc"><div class="markdown"><p>Make an auto-closeable video decoder - you can use this decoder with <code>with-open</code>.  Do not assume that you can keep a reference to the frame data; it is only good  until the next <code>decode-frame!</code> call.</p>
<p>:Options</p>
<ul>
  <li><code>:output-pixfmt</code> - a valid ffmpeg pixfmt string. Defaults to AV_PIX_FMT_BGR24 as this  corresponds to buffered-image :byte-bgr format. For list of valid pixfmt strings  see <code>(keys avclj.av-pixfmt/pixvmt-name-value-map)</code>.</li>
  <li><code>:output-height</code>, <code>:output-width</code> - If none are specified, use video width/height. If one is specified use aspect-ratio-preserving scaling to find the other. If both are specified use these precisely. This may distort the image.</li>
</ul>
<p>Example:</p>
<pre><code class="clojure">user&gt; (require '[tech.v3.datatype :as dtype])
nil
user&gt; (require '[tech.v3.libs.buffered-image :as bufimg])
nil
user&gt; (require '[avclj :as avclj])
nil
user&gt; (avclj/initialize!)
:ok
user&gt; (def decoder (avclj/make-video-decoder "test/data/test-video.mp4"))
#'user/decoder
user&gt; (meta decoder)
{:time-base {:num 1, :den 15360},
 :width 256,
 :height 256,
 :pix-fmt ["AV_PIX_FMT_BGR24"]}
user&gt; ;;frame data is a sequence of buffers, the exact format is dependent upon pix-fmt
user&gt; (def frame-data (avclj/decode-frame! decoder))
#'user/frame-data
user&gt; frame-data
[#native-buffer@0x00007F3C17383FC0&lt;uint8&gt;[196608]
[250, 253, 251, 250, 253, 251, 250, 253, 251, 250, 253, 251, 250, 253, 251, 250, 253, 251, 250, 253...]]
user&gt; (meta frame-data)
{:pts 0, :width 256, :height 256}
user&gt; ;;use (/ (* pts num) den) to get actual frame ms offset.
user&gt; (def dest-img (bufimg/new-image ((meta decoder) :height) ((meta decoder) :width) :byte-bgr))
#'user/dest-img
user&gt; (dtype/copy! (first frame-data) dest-img)
#object[java.awt.image.BufferedImage 0x115e9eaf "BufferedImage@115e9eaf: type = 5 ColorModel: #pixelBits = 24 numComponents = 3 color space = java.awt.color.ICC_ColorSpace@154aafe6 transparency = 1 has alpha = false isAlphaPre = false ByteInterleavedRaster: width = 256 height = 256 #numDataElements 3 dataOff[0] = 2"]
user&gt; (bufimg/save! dest-img "test.png")
true
user&gt; (.close decoder)
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/avclj/blob/master/src/avclj.clj#L491">view source</a></div></div><div class="public anchor" id="var-make-video-encoder"><h3>make-video-encoder</h3><div class="usage"><code>(make-video-encoder height width out-fname {:keys [fps-numerator fps-denominator input-pixfmt encoder-pixfmt encoder-name file-format bit-rate codec-options codec-private-options], :or {fps-numerator 60, fps-denominator 1, input-pixfmt "AV_PIX_FMT_BGR24", encoder-pixfmt "AV_PIX_FMT_YUV420P", encoder-name "mpeg4"}})</code><code>(make-video-encoder height width output-fname)</code></div><div class="doc"><div class="markdown"><p>Make a video encoder.</p>
<ul>
  <li><code>height</code> - divisible by 2</li>
  <li><code>width</code> - divisible by 2</li>
  <li><code>out-fname</code> - Output filepath. Must be a c-addressable file path, not a url or  an input stream. The file format will be divined from the file extension.</li>
</ul>
<p>Selected Options:</p>
<ul>
  <li><code>:input-pixfmt</code> - One of the pixel formats. Defaults to “AV_PIX_FMT_BGR24”</li>
  <li><code>:encoder-pixfmt</code> - One of the pixel formats. Defaults to “AV_PIX_FMT_YUV420P”.  Changing this will probably cause opening the codec to fail with an  invalid argument. To see the valid encoder pixel formats, use find-encoder  and analyze the <code>:pix-fmts</code> member.</li>
  <li><code>:encoder-name</code> - Name (or integer codec id) of the encoder to use.</li>
  <li><code>:fps-numerator</code> - :int32 defaults to 60.</li>
  <li><code>:fps-denominator</code> - :int32 defaults to 1.</li>
  <li><code>:codec-options</code> - Map of string option name to string option key.</li>
  <li><code>:codec-private-options</code> - Codec-private options you can set. For libx264 an example  is {“preset” “slow”}.</li>
  <li><code>:bit-rate</code> - If specified, the system will set a constant bit-rate for the video. In  this case with h264 encoding it will switch from crf encoding to abr encoding with a  40 frame rate control look-ahead.</li>
</ul></div></div><div class="src-link"><a href="https://github.com/cnuernber/avclj/blob/master/src/avclj.clj#L292">view source</a></div></div><div class="public anchor" id="var-PVideoDecoder"><h3>PVideoDecoder</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-decode-frame.21"><h3>decode-frame!</h3><div class="usage"><code>(decode-frame! decoder)</code></div><div class="doc"><div class="markdown"><p>Decode a frame returning a persistent vector of buffers, one for each data plane in the frame. When this function returns nil there are no more frames to decode. Users can expect the frames will be decoded in-place so the data is only valid until the next decode-frame! call</p></div></div></div></div></div><div class="src-link"><a href="https://github.com/cnuernber/avclj/blob/master/src/avclj.clj#L82">view source</a></div></div><div class="public anchor" id="var-PVideoEncoder"><h3>PVideoEncoder</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-encode-frame.21"><h3>encode-frame!</h3><div class="usage"><code>(encode-frame! enc frame)</code></div><div class="doc"><div class="markdown"><p>Handle a frame of data. A frame is a persistent vector of buffers, one for each data plane. If you are passing in a nio buffer, ensure to require ’tech.v3.datatype.nio-buffer` for zero-copy support. If frame is not a persistent vector it is assumed to a single buffer and is wrapped in a persistent vector</p></div></div></div></div></div><div class="src-link"><a href="https://github.com/cnuernber/avclj/blob/master/src/avclj.clj#L74">view source</a></div></div></div></body></html>